<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Ordenar Frases</title>
  <style>
    .container {
      display: flex;
      flex-direction: column;
      align-items: center;
      margin-top: 20px;
      font-family: Arial, sans-serif;
    }
    /* Depósito: área de posicionamiento libre ampliada */
    .deposito {
      position: relative; /* Los elementos con position:absolute se ubican respecto a este contenedor */
      width: 80%;
      height: 400px;  /* Área aumentada para mover libremente */
      padding: 10px;
      border: 2px dashed #999;
      background-color: #fff;
      margin-bottom: 20px;
      overflow: auto;
    }
    /* Caja de frase: se posiciona de forma absoluta dentro del depósito */
    .phrase {
      position: absolute;
      padding: 10px;
      background-color: lightblue;
      border: 1px solid #000;
      cursor: grab;
      user-select: none;
      width: 130px;
      min-height: 40px;
      box-sizing: border-box;
    }
    /* Grilla de ordenación */
    .grid {
      display: flex;
      gap: 10px;
      margin-bottom: 10px;
    }
    .column {
      display: flex;
      flex-direction: column;
      align-items: center;
    }
    .column h3 {
      margin: 0 0 5px 0;
    }
    .slot {
      width: 130px;
      height: 90px;
      border: 2px solid #ccc;
      margin: 1px;
      display: flex;
      align-items: center;
      justify-content: center;
      background-color: #f9f9f9;
      font-size: 10px;
      box-sizing: border-box;
    }
  </style>
</head>
<body>
  <div class="container">
    <h2>Frases a ordenar</h2>
    <div class="deposito" id="deposito">
      <!-- Las 32 frases se crearán dinámicamente -->
    </div>

    <h2>Grilla de Ordenación</h2>
    <div class="grid" id="grid">
      <!-- Se generará la grilla según la estructura y cantidad de slots -->
    </div>
    
    <button onclick="generarEnlace()">Generar Enlace</button>
    <input type="text" id="link" readonly style="width: 80%; margin-top: 10px;">
  </div>

  <script>
    // Array de 32 frases
    const frases = [
      "La innovación es el resultado de la transferencia de tecnología de expertos a productores",
      "Los productores para innovar necesitan recibir las tecnologías generadas por especialistas y empresas",
      "Para innovar, es necesario debatir y pensar junto con personas que tengan distintas ideas y puntos de vista sobre el asunto",
      "Las mejores soluciones las encontramos discutiendo y trabajando con personas que tengan conocimientos y experiencias valiosas",
      "Innovar es usar tecnología de punta como drones o agricultura de precisión",
      "Hay que estar en la vanguardia de las últimas tecnologías",
      "A los productores les gusta ver y probar cómo funcionan las cosas antes de usarlas",
      "Aprender a partir de la experiencia es fundamental para los productores, no sirven las reuniones que son como clases",
      "Los productores adecuan las tecnologías disponibles para que les resulten útiles a su situación",
      "Los productores son creativos y prueban constantemente nuevas estrategias y formas de trabajar y producir",
      "Los productores no son realmente innovadores, el sector agropecuario es conservador",
      "Los productores en general son bastante reacios a innovar",
      "Los extensionistas o asesores son responsables de transferir tecnologías y de persuadir a los productores para que las adopten",
      "Las tecnologías ya están disponibles, los asesores y extensionistas tienen que enseñarlas a los productores",
      "Para un buen asesor o extensionista, los conocimientos y experiencias de los productores son fundamentales",
      "El rol de los extensionistas o asesores es acompañar el proceso de toma de decisiones de los productores",
      "La labor de asesoramiento o extensión debe partir de lo que le piden sus productores",
      "Los productores son los responsables de traccionar y demandar a asesores o extensionistas para que respondan a sus necesidades",
      "Los investigadores tienen el rol de generar tecnologías y conocimientos para innovar",
      "Los investigadores facilitan el trabajo del productor creando soluciones tecnológicas confiables",
      "Los investigadores hacen aportes descontextualizados, poco útiles para los productores",
      "Los investigadores tienen una mirada poco realista sobre cómo se produce",
      "Pensar siempre en aumentar las ganancias nos está llevando a la destrucción de los ecosistemas",
      "Estoy convencido que la agroecología es el camino",
      "Hay que usar herbicidas porque intentar ahorrar en los controles de malezas puede salir muy caro",
      "En los mejores campos no hay problema con seguir aplicando el modelo de agricultura industrial convencional",
      "Los agroquímicos deben usarse con mucho cuidado: son tóxicos pero también son necesarios para conseguir una buena producción",
      "Tenemos que adoptar modelos que sean altamente productivos pero que a la vez sean amigables con la naturaleza.",
      "La confianza entre productores y sus asesores y/o extensionistas es clave para obtener buenos resultados.",
      "Un buen vínculo entre asesores/extensionistas y productores es más importante que la excelencia técnica.",
      "El gobierno debe apoyar producciones estratégicas para fomentar el desarrollo nacional.",
      "El gobierno no debe meterse con los productores, qué producir y cómo es decisión del productor."
    ];

    // Estructura de la grilla: columnas y cantidad de slots (total 32)
    const estructura = [-4, -3, -2, -1, 0, 1, 2, 3, 4];
    const espacios = [2, 3, 4, 4, 6, 4, 4, 3, 2];

    const deposito = document.getElementById("deposito");
    const grid = document.getElementById("grid");

    // Crear elemento para cada frase con posición absoluta
    function crearFraseElement(text, left, top) {
      const div = document.createElement("div");
      div.classList.add("phrase");
      div.textContent = text;
      // Se asigna posición inicial (si no se pasa, se coloca en 0,0)
      div.style.left = left + "px";
      div.style.top = top + "px";
      // Eventos para arrastre libre
      div.addEventListener("mousedown", iniciarArrastre);
      return div;
    }

    // Distribuir las 32 frases en el depósito (por ejemplo, en un grid interno)
    const gapX = 10, gapY = 10, phraseWidth = 130, phraseHeight = 50;
    frases.forEach((frase, index) => {
      const col = index % 8;
      const row = Math.floor(index / 8);
      const left = 10 + col * (phraseWidth + gapX);
      const top = 10 + row * (phraseHeight + gapY);
      const fraseElem = crearFraseElement(frase, left, top);
      deposito.appendChild(fraseElem);
    });

    // Generar la grilla de ordenación según la estructura definida
    estructura.forEach((nombre, index) => {
      const column = document.createElement("div");
      column.classList.add("column");
      const label = document.createElement("h3");
      label.textContent = nombre;
      column.appendChild(label);
      for (let i = 0; i < espacios[index]; i++) {
        const slot = document.createElement("div");
        slot.classList.add("slot");
        // No usamos eventos nativos de drag & drop; la detección se hará en el free drag
        column.appendChild(slot);
      }
      grid.appendChild(column);
    });

    // Variables para el movimiento libre
    let offsetX, offsetY, currentDragged = null;

    function iniciarArrastre(event) {
      currentDragged = event.currentTarget;
      // Lleva el elemento al frente
      currentDragged.style.zIndex = 1000;
      offsetX = event.clientX - currentDragged.getBoundingClientRect().left;
      offsetY = event.clientY - currentDragged.getBoundingClientRect().top;
      document.addEventListener("mousemove", moverElemento);
      document.addEventListener("mouseup", finalizarArrastre);
    }

    function moverElemento(event) {
      if (!currentDragged) return;
      const contenedorRect = deposito.getBoundingClientRect();
      let nuevaIzquierda = event.clientX - contenedorRect.left - offsetX;
      let nuevaArriba = event.clientY - contenedorRect.top - offsetY;
      // Limitar para que no se salga del depósito
      if (nuevaIzquierda < 0) nuevaIzquierda = 0;
      if (nuevaArriba < 0) nuevaArriba = 0;
      if (nuevaIzquierda + currentDragged.offsetWidth > deposito.offsetWidth) {
        nuevaIzquierda = deposito.offsetWidth - currentDragged.offsetWidth;
      }
      if (nuevaArriba + currentDragged.offsetHeight > deposito.offsetHeight) {
        nuevaArriba = deposito.offsetHeight - currentDragged.offsetHeight;
      }
      currentDragged.style.left = nuevaIzquierda + "px";
      currentDragged.style.top = nuevaArriba + "px";
    }

    function finalizarArrastre(event) {
      if (!currentDragged) return;
      currentDragged.style.zIndex = "";
      document.removeEventListener("mousemove", moverElemento);
      document.removeEventListener("mouseup", finalizarArrastre);
      
      // Al soltar, se verifica si la frase se encuentra sobre algún slot de la grilla
      const fraseRect = currentDragged.getBoundingClientRect();
      const slots = document.querySelectorAll(".slot");
      let dropped = false;
      slots.forEach(slot => {
        const slotRect = slot.getBoundingClientRect();
        // Se verifica intersección (colisión simple)
        if (
          fraseRect.left < slotRect.right &&
          fraseRect.right > slotRect.left &&
          fraseRect.top < slotRect.bottom &&
          fraseRect.bottom > slotRect.top &&
          slot.childNodes.length === 0 // sólo se coloca si el slot está vacío
        ) {
          // Se transfiere la frase al slot
          currentDragged.removeEventListener("mousedown", iniciarArrastre);
          // Quitar estilos de posición para que se acomode dentro del slot
          currentDragged.style.position = "static";
          currentDragged.style.left = "";
          currentDragged.style.top = "";
          slot.appendChild(currentDragged);
          dropped = true;
        }
      });
      // Si no se soltó en ningún slot, la frase queda en su posición libre en el depósito.
      currentDragged = null;
    }

    // Función para generar un enlace que incluya el orden de la grilla
    function generarEnlace() {
      const slots = document.querySelectorAll(".slot");
      const posiciones = [];
      slots.forEach(slot => {
        posiciones.push(slot.firstChild ? slot.firstChild.textContent : "");
      });
      const url = new URL(window.location.href);
      url.searchParams.set("orden", encodeURIComponent(JSON.stringify(posiciones)));
      document.getElementById("link").value = url.href;
    }

    // Al cargar, si hay un parámetro "orden" en la URL se coloca cada frase en su slot correspondiente.
    window.onload = function() {
      const params = new URLSearchParams(window.location.search);
      if (params.has("orden")) {
        const posiciones = JSON.parse(decodeURIComponent(params.get("orden")));
        const slots = document.querySelectorAll(".slot");
        posiciones.forEach((texto, index) => {
          if (texto && slots[index]) {
            // Si la frase ya está en el depósito, se retira para evitar duplicados
            const existente = Array.from(deposito.children).find(el => el.textContent === texto);
            if (existente) {
              existente.removeEventListener("mousedown", iniciarArrastre);
              existente.style.position = "static";
              existente.style.left = "";
              existente.style.top = "";
              slots[index].appendChild(existente);
            } else {
              let phraseDiv = document.createElement("div");
              phraseDiv.className = "phrase";
              phraseDiv.textContent = texto;
              phraseDiv.style.position = "static";
              slots[index].appendChild(phraseDiv);
            }
          }
        });
      }
    };
  </script>
</body>
</html>
